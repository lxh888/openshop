在config表中，有很多配置信息，客户需要自定义修改。这个时候就需要后台将其视图化管理。不同的模块，对应不同的配置管理，所以存在多个配置接口，下面以应用模块中的配置举例。
### 在request/application/admin_config.php控制器中添加配置“获取接口”
```
/**
 * 获取配置数据
 * $data = array(
 * 	"config_id" = "", //获取某一个配置信息。不传该值则代表默认获取全部
 * )
 * 接口ID:APPLICATIONADMINCONFIGDATA
 * @param	array	$data
 * @return	array
 */
public function api_data($data = array());
```
$data['config_id']是获取某一个配置。不传该值则代表默认获取全部，而全部是指api_data中所允许的配置。
所以，后端人员在写该接口时，如果该模块的控制器存在及其方法也存在，只需要在上面代码中添加一组配置ID就行了：
```
//所在 api_data() 类方法：
$config = array(
    'app_android_version',
    'weixin_applet_access',
    'weixin_app_access',
    'shop_config',
    'shop_distribution_reward'
    //...可添加其他需要后台管理视图化的配置...
);
```
这样后台的前端，请求这个接口时，就能获取可设置的全部接口或某一个配置信息。

### 在request/application/admin_config.php控制器中添加配置“设置接口”
```
/**
 * 编辑配置信息
 * 接口ID:APPLICATIONADMINCONFIGEDIT
 * @param	array	$data
 * @return	bool
 */
public function api_edit($data = array());
```
该接口是接受前端提交变更的数据。
注意步骤，第一步是判断这个配置是否存在，因为不同的项目，配置不同，所以有可能当前项目不存在该配置。为了防止前端脏提交，需要验证：
```
//所在 api_edit() 类方法：
$old = object(parent::TABLE_CONFIG)->find('shop_config');//获取配置旧数据
if( empty($old) ){
    throw new error('未知配置编辑');
}
```
紧接着就是验证数据的合法性，防止脏数据或报错。给一个数组键名称白名单，把脏数据剔除掉，然后将数据转为JSON字符串，准备存入数据库。
```
//所在 api_edit() 类方法：
//白名单，只保留白名单的键名称，把脏键名称剔除掉
$whitelist = array(
     'daily_attendance', 
     'register_credit',
    'register_coupon'
);
$whitelist_data = cmd(array($data['shop_config'], $whitelist), 'arr whitelist');
$value = cmd(array($whitelist_data), 'json encode');
```
当然在存入数据库之前，就要匹配新数据是否与就数据一致，一致说明数据没有被修改，就返回一个错误提示前端数据没有被修改过。







